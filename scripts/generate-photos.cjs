#!/usr/bin/env node
/* AUTO-GENERATE photos.ts from /public/img/** */
const fs = require('fs');
const path = require('path');

let getSize = null;
try { getSize = require('image-size'); } catch (_) { /* optional */ }

const ROOT = process.cwd();
const PUBLIC_IMG = path.join(ROOT, 'public', 'img');
const ERA_DIRS = ['childhood', 'ams', 'ftu', 'uk'];
const exts = new Set(['.jpg', '.jpeg', '.png', '.webp', '.avif', '.gif']);

function toPosix(p) { return p.split(path.sep).join(path.posix.sep); }
function naturalCompare(a, b) { return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }); }

function listFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs.readdirSync(dir, { withFileTypes: true }).flatMap(d => {
    const p = path.join(dir, d.name);
    if (d.isDirectory()) return listFiles(p);
    const ext = path.extname(d.name).toLowerCase();
    if (!exts.has(ext)) return [];
    return [p];
  });
}

function prettyName(file) {
  const base = path.basename(file, path.extname(file));
  return base.replace(/[_\-]+/g, ' ').replace(/\s+/g, ' ').trim() || 'Photo';
}

function main() {
  if (!fs.existsSync(PUBLIC_IMG)) {
    console.error('Not found: public/img');
    process.exit(1);
  }

  const items = [];
  for (const era of ERA_DIRS) {
    const dir = path.join(PUBLIC_IMG, era);
    if (!fs.existsSync(dir)) { console.warn('Skip missing:', dir); continue; }
    const files = listFiles(dir).sort(naturalCompare);

    for (const abs of files) {
      const rel = toPosix(path.relative(path.join(ROOT, 'public'), abs)); // e.g. img/ftu/01.jpg
      const src = `/${rel}`; // e.g. /img/ftu/01.jpg
      const alt = `${era.toUpperCase()} - ${prettyName(abs)}`;
      let w, h;
      if (getSize) {
        try { const dim = getSize(abs); w = dim.width; h = dim.height; } catch {}
      }
      items.push({ src, alt, era, w, h });
    }
  }

  // sort by era then by name
  const eraRank = Object.fromEntries(ERA_DIRS.map((e, i) => [e, i]));
  items.sort((a, b) => eraRank[a.era] - eraRank[b.era] || naturalCompare(a.src, b.src));

  const out = path.join(ROOT, 'src', 'app', 'data', 'photos.ts');
  fs.mkdirSync(path.dirname(out), { recursive: true });

  const header =
`// AUTO-GENERATED by scripts/generate-photos.cjs - do not edit by hand
export type Era = 'childhood' | 'ams' | 'ftu' | 'uk';
export type Mood = 'cute' | 'charming';
export type PhotoItem = { src:string; alt:string; era:Era; mood?:Mood[]; caption?:string; w?:number; h?:number };

export const photos: PhotoItem[] = [
`;
  const body = items.map(it => {
    const dims = (it.w && it.h) ? `, w:${it.w}, h:${it.h}` : '';
    const alt = it.alt.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
    return `  { src: '${it.src}', alt: \`${alt}\`, era: '${it.era}'${dims} },`;
  }).join('\n');
  const footer =
`
];
// Tip: add 'mood' and 'caption' manually after generation, example:
// { src:'...', alt:'...', era:'uk', mood:['charming'], caption:'Bristol day' }
`;

  fs.writeFileSync(out, header + body + footer, 'utf8');
  console.log(`Wrote ${items.length} photos -> ${toPosix(path.relative(ROOT, out))}`);
}

main();